"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermissionAction = void 0;
exports.grantPermission = grantPermission;
const module_sdk_1 = require("@rhinestone/module-sdk");
const account_abstraction_1 = require("viem/account-abstraction");
const utils_1 = require("viem/utils");
const account_1 = require("../../../account/index.js");
const AccountNotFound_1 = require("../../../account/utils/AccountNotFound.js");
const constants_1 = require("../../../constants/index.js");
const SmartSessionAbi_1 = require("../../../constants/abi/SmartSessionAbi.js");
const Helpers_1 = require("../Helpers.js");
const getPermissionAction = async ({ chainId, sessionRequestedInfo, client }) => {
    const sessions = [];
    const permissionIds = [];
    const resolvedPolicyInfo2ActionData = (actionPolicyInfo) => {
        const actionConfig = (0, Helpers_1.createActionConfig)(actionPolicyInfo.rules ?? [], actionPolicyInfo.valueLimit);
        const policyData = [];
        const uniActionPolicyInfo = (0, Helpers_1.toUniversalActionPolicy)(actionConfig);
        policyData.push(uniActionPolicyInfo);
        const timeFramePolicyData = (0, Helpers_1.toTimeRangePolicy)(actionPolicyInfo.validUntil ?? 0, actionPolicyInfo.validAfter ?? 0);
        policyData.push(timeFramePolicyData);
        if (actionPolicyInfo.sudo) {
            const sudoPolicy = (0, module_sdk_1.getSudoPolicy)();
            policyData.push(sudoPolicy);
        }
        if (actionPolicyInfo.valueLimit) {
            const valueLimitPolicy = (0, module_sdk_1.getValueLimitPolicy)({
                limit: actionPolicyInfo.valueLimit
            });
            policyData.push(valueLimitPolicy);
        }
        if (actionPolicyInfo.usageLimit) {
            const usageLimitPolicy = (0, module_sdk_1.getUsageLimitPolicy)({
                limit: actionPolicyInfo.usageLimit
            });
            policyData.push(usageLimitPolicy);
        }
        if (actionPolicyInfo.tokenLimits?.length) {
            const spendingLimitPolicy = (0, module_sdk_1.getSpendingLimitsPolicy)(actionPolicyInfo.tokenLimits);
            policyData.push(spendingLimitPolicy);
        }
        const actionPolicy = (0, Helpers_1.createActionData)(actionPolicyInfo.contractAddress, actionPolicyInfo.functionSelector, policyData);
        return actionPolicy;
    };
    for (const sessionInfo of sessionRequestedInfo) {
        const actionPolicies = [];
        for (const actionPolicyInfo of sessionInfo.actionPoliciesInfo ?? []) {
            if (actionPolicyInfo.abi) {
                const resolvedPolicyInfos = (0, Helpers_1.abiToPoliciesInfo)(actionPolicyInfo);
                const actionPolicies_ = resolvedPolicyInfos.map(resolvedPolicyInfo2ActionData);
                actionPolicies.push(...actionPolicies_);
            }
            else {
                const actionPolicy = resolvedPolicyInfo2ActionData(actionPolicyInfo);
                actionPolicies.push(actionPolicy);
            }
        }
        const userOpTimeFramePolicyData = (0, Helpers_1.toTimeRangePolicy)(sessionInfo.sessionValidUntil ?? 0, sessionInfo.sessionValidAfter ?? 0);
        const session = {
            chainId: BigInt(chainId),
            sessionValidator: sessionInfo.sessionValidatorAddress ?? constants_1.SIMPLE_SESSION_VALIDATOR_ADDRESS,
            sessionValidatorInitData: sessionInfo.sessionKeyData,
            salt: sessionInfo.salt ?? (0, Helpers_1.generateSalt)(),
            userOpPolicies: [userOpTimeFramePolicyData],
            actions: actionPolicies,
            erc7739Policies: {
                allowedERC7739Content: [],
                erc1271Policies: []
            }
        };
        const permissionId = await (0, Helpers_1.getPermissionId)({
            client,
            session
        });
        permissionIds.push(permissionId);
        sessions.push(session);
    }
    const grantPermissionData = (0, utils_1.encodeFunctionData)({
        abi: SmartSessionAbi_1.SmartSessionAbi,
        functionName: "enableSessions",
        args: [sessions]
    });
    return {
        action: {
            target: module_sdk_1.SMART_SESSIONS_ADDRESS,
            value: BigInt(0),
            callData: grantPermissionData
        },
        permissionIds: permissionIds
    };
};
exports.getPermissionAction = getPermissionAction;
async function grantPermission(client, parameters) {
    const { publicClient: publicClient_ = client.account?.client, account: account_ = client.account, maxFeePerGas, maxPriorityFeePerGas, nonce, sessionRequestedInfo, attesters } = parameters;
    if (!account_) {
        throw new AccountNotFound_1.AccountNotFoundError({
            docsPath: "/nexus-client/methods#sendtransaction"
        });
    }
    const account = (0, utils_1.parseAccount)(account_);
    if (!account || !account.address) {
        throw new Error("Account not found");
    }
    const chainId = publicClient_?.chain?.id;
    if (!chainId) {
        throw new Error(account_1.ERROR_MESSAGES.CHAIN_NOT_FOUND);
    }
    const defaultedSessionRequestedInfo = sessionRequestedInfo.map(Helpers_1.applyDefaults);
    const attestersToTrust = attesters ?? [module_sdk_1.MOCK_ATTESTER_ADDRESS];
    const actionResponse = await (0, exports.getPermissionAction)({
        chainId,
        client: publicClient_,
        sessionRequestedInfo: defaultedSessionRequestedInfo
    });
    const trustAttestersAction = (0, module_sdk_1.getTrustAttestersAction)({
        attesters: attestersToTrust,
        threshold: attestersToTrust.length
    });
    const trustedAttesters = await (0, module_sdk_1.findTrustedAttesters)({
        client: publicClient_,
        accountAddress: account.address
    });
    const needToAddTrustAttesters = trustedAttesters.length === 0;
    console.log("needToAddTrustAttesters", needToAddTrustAttesters);
    if (!("action" in actionResponse)) {
        throw new Error("Error getting enable sessions action");
    }
    const { action } = actionResponse;
    if (!("callData" in action)) {
        throw new Error("Error getting enable sessions action");
    }
    if (!("callData" in trustAttestersAction)) {
        throw new Error("Error getting trust attesters action");
    }
    const calls = [];
    if (needToAddTrustAttesters) {
        calls.push({
            to: trustAttestersAction.target,
            value: trustAttestersAction.value.valueOf(),
            data: trustAttestersAction.callData
        });
    }
    calls.push({
        to: action.target,
        value: action.value,
        data: action.callData
    });
    if ("action" in actionResponse) {
        const userOpHash = (await (0, utils_1.getAction)(client, account_abstraction_1.sendUserOperation, "sendUserOperation")({ calls, maxFeePerGas, maxPriorityFeePerGas, nonce, account }));
        return {
            userOpHash: userOpHash,
            ...actionResponse
        };
    }
    throw new Error("Error getting enable sessions action");
}
//# sourceMappingURL=grantPermission.js.map