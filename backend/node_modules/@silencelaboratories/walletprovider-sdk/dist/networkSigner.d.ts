import { AuthModule, UserAuthentication } from './authentication';
import { GetQueryPath, QueryPath, type IWalletProviderServiceClient } from './walletProviderServiceClientInterface';
import { EphClaim } from './ephemeralAuthentication';
/**
 * Response from the network for keygen requests
 * @alpha
 */
export interface KeygenResponse {
    /**
     * Unique ID of produced key used in subsequent API calls.
     */
    keyId: string;
    /**
     * Public key encoded with SEC1 format.
     *
     * If point is uncompressed it's in a form of 0x04 || X || Y
     *
     * If point is compressed it's in a form Y || X,
     *
     * where Y is set to 0x02 if Y-coord is even, or 0x03 if Y-coord is odd
     */
    publicKey: string;
    /**
     * Optional credential id used for passkey authentication.
     *
     * Returned by Authenticator.
     */
    passkeyCredentialId?: string;
}
/**
 * Response from the network for sign request
 * @alpha
 */
export interface SignResponse {
    /**
     * Hexstring of length 128 bytes, in a form: r || s
     */
    sign: string;
    /**
     * Recovery id, either 0, or 1
     */
    recid: number;
}
/**
 * Response from the network for adding ephemeral key request
 * @alpha
 */
export interface AddEphemeralKeyResponse {
    status: string;
}
/** Key parameters used during generation  */
export declare class KeygenSetupOpts implements GetQueryPath {
    /** Threshold, number of parties that needs to participate in a protocol in order to produce valid signature */
    t: number;
    /** Total number of nodes that participate in Key generation, must be greater or equal than `t` */
    n: number;
    /** Optional key label */
    key_label?: string;
    /** Metadata for a key. Currently they store the permissions, can be set in a constructor of this class.
      If permissions are not set, all operations are allowed.
     */
    private metadata;
    constructor({ t, n, key_label, permissions, }: {
        t: number;
        n: number;
        key_label: string | undefined;
        permissions: string | undefined;
    });
    set ephClaim(ephClaim: EphClaim);
    get queryPath(): QueryPath;
    get requestSchema(): {
        Request: {
            name: string;
            type: string;
        }[];
        KeygenSetupOpts: {
            name: string;
            type: string;
        }[];
        TaggedValue: {
            name: string;
            type: string;
        }[];
    };
}
/** Parameters used in Signature execution */
export declare class SignSetupOpts implements GetQueryPath {
    /** Number of nodes that will participate in the signature execution */
    t: number;
    /** Select the key using it's ID */
    key_id: string;
    /** The message to sign */
    message: string;
    constructor({ t, key_id, message }: {
        t: number;
        key_id: string;
        message: string;
    });
    get queryPath(): QueryPath;
}
export declare class AddEphemeralKeyOpts implements GetQueryPath {
    /** Total number of nodes that participate in Adding Ephemeral Key */
    n: number;
    /** Select the key using it's ID */
    key_id: string;
    /** Metadata for a key. Currently they store the permissions, can be set in a constructor of this class.
      If permissions are not set, all operations are allowed.
     */
    private metadata;
    constructor({ n, key_id }: {
        n: number;
        key_id: string;
    });
    set ephClaim(ephClaim: EphClaim);
    get queryPath(): QueryPath;
    get requestSchema(): {
        Request: {
            name: string;
            type: string;
        }[];
        AddEphemeralKeyOpts: {
            name: string;
            type: string;
        }[];
        TaggedValue: {
            name: string;
            type: string;
        }[];
    };
}
/** The `user_authentication` contains signature over the `setup` parameter. */
export type UserAuthenticatedRequest<T> = {
    setup: T;
    user_authentication: UserAuthentication;
};
/** The networkSigner contains an API to communicate with the Silent MPC Network. Call to sign and keygen require
 * the Auth module, that is used to prompt the User before executing the request.
 * @alpha
 */
export declare class NetworkSigner {
    /** Authentication module, used to get confirmation from the User before request execution */
    authModule: AuthModule;
    /** Number of nodes that needs to participate in protocol in order to generate valid signature. Also known as `t`. */
    threshold: number;
    /** Number of nodes that participate in keygen operation. Also known as `n`. */
    totalNodes: number;
    /** Wallet Provider backend client */
    wp_client: IWalletProviderServiceClient;
    /**
     * Facade class used to execute operations on Silent Network.
     * @param wpClient - Wallet Provider backend client
     * @param threshold - Number of nodes that needs to participate in protocol in order to generate valid signature. Also known as `t`.
     * @param totalNodes - Number of nodes that participate in keygen operation. Also known as `n`.
     * @param authModule - Authentication module, used to get confirmation from the User before request execution
     */
    constructor(wpClient: IWalletProviderServiceClient, threshold: number, totalNodes: number, authModule: AuthModule);
    /** Generate a distributed key that's generated by Silent Network.
     * Uses `authModule` to authenticate the User with the Silent Network.
     * @param permissions - optional permissions that will be stored in the key metadata.
     * The permissions are validated during sign requests.
     * @returns {@link KeygenResponse} containing `keyId` and the `pubKey` public part of the key
     * @public
     */
    generateKey(permissions?: string): Promise<KeygenResponse>;
    /** Generate a signature by the distributed key of Silent Network.
     * Uses `authModule` to authenticate the sign request by the User.
     * The network chooses `t` nodes to execute the protocol.
     * @param keyId - the key id returned from `keygen`
     * @param message - the message to sign by the MPC network
     * @returns {@link SignResponse}
     * @public
     */
    signMessage(keyId: string, message: string): Promise<SignResponse>;
    /** Add new ephemeral key to an exist distributed key on the network.
     * Uses `authModule` to authenticate the request by the User.
     * @param keyId - the key id returned from `keygen`
     * @returns {@link AddEphemeralKeyResponse}
     * @public
     */
    addEphemeralKey(keyId: string): Promise<AddEphemeralKeyResponse>;
    private setEphClaimOf;
}
