var $=Object.defineProperty,F=Object.defineProperties;var V=Object.getOwnPropertyDescriptors;var O=Object.getOwnPropertySymbols;var H=Object.prototype.hasOwnProperty,L=Object.prototype.propertyIsEnumerable;var w=(n,e,t)=>e in n?$(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,y=(n,e)=>{for(var t in e||(e={}))H.call(e,t)&&w(n,t,e[t]);if(O)for(var t of O(e))L.call(e,t)&&w(n,t,e[t]);return n},A=(n,e)=>F(n,V(e));var s=(n,e,t)=>w(n,typeof e!="symbol"?e+"":e,t);import{Base64 as Q}from"js-base64";var k=n=>btoa(String.fromCodePoint.apply(null,Array.from(n))),c=n=>Q.fromUint8Array(new Uint8Array(n),!0);var h=(n,e)=>{u(typeof e!="string","".concat(n," must be string")),u((e==null?void 0:e.trim().length)===0,"".concat(n," cannot be empty"))},S=n=>{u(!(n instanceof Uint8Array),"key must be an Uint8Array"),u(n.length!==32,"ed25519: key length must be 32 bytes")},u=(n,e)=>{if(n)throw new Error(e)};var C=class{constructor(e){s(this,"walletProviderId");s(this,"walletProviderUrl");s(this,"passkeyCredentialId");this.walletProviderId=e.walletProviderId,this.walletProviderUrl=e.walletProviderUrl}getWalletId(){return this.walletProviderId}async startKeygen({setup:e,authModule:t}){return this.connect(e,t).then(r=>{var p,l;let i=r.split(":");u(i.length!==2,"Invalid keygen response from network");let a=(p=i[0])==null?void 0:p.split("=")[1];return{publicKey:(l=i[1])==null?void 0:l.split("=")[1],keyId:a,passkeyCredentialId:this.passkeyCredentialId}})}async startSigngen({setup:e,authModule:t}){return this.connect(e,t).then(r=>{var p,l;let i=r.split(":");u(i.length!==2,"Invalid signgen response from network");let a=(p=i[0])==null?void 0:p.split("=")[1],o=(l=i[1])==null?void 0:l.split("=")[1];if(a===void 0||o===void 0)throw new Error("Invalid signgen response from network");return{sign:a,recid:parseInt(o)}})}async addEphemeralKey({setup:e,authModule:t}){return this.connect(e,t).then(r=>({status:r}))}connect(e,t){return new Promise((r,i)=>{let a=0,o=e.queryPath;o==="signgen"&&(e.message=k(new TextEncoder().encode(e.message)));let p=new WebSocket("".concat(this.walletProviderUrl,"/").concat(o));p.addEventListener("open",l=>{switch(console.debug("Connection opened in state ".concat(a," with event ").concat(JSON.stringify(l,void 0,"	"))),a){case 0:a=1,p.send(JSON.stringify(e));break;case 1:case 2:a=3,i("Incorrect protocol state");break;case 3:break}}),p.addEventListener("message",async l=>{switch(console.debug("Connection message in state ".concat(a," with event ").concat(JSON.stringify(l,void 0,"	"))),a){case 0:a=3,i("Incorrect protocol state");break;case 1:{a=2;try{let d=await t.authenticate({setup:e,challenge:l.data});d.credentials.method==="passkey"&&(this.passkeyCredentialId=d.credentials.id),p.send(JSON.stringify(d))}catch(d){i(d)}break}case 2:a=3,p.close(),r(l.data);break;case 3:break}}),p.addEventListener("error",l=>{console.debug("Connection error in state ".concat(a," with event ").concat(JSON.stringify(l,void 0,"	"))),a!=3&&(a=3,i("Incorrect protocol state"))}),p.addEventListener("close",l=>{console.debug("Connection closed in state ".concat(a," with event ").concat(JSON.stringify(l,void 0,"	"))),a!=3&&(a=3,i("Incorrect protocol state"))})})}};var G=1,x=2,z=3,U=[{name:"tag",type:"uint16"},{name:"value",type:"string"}],g=class{constructor({t:e,n:t,key_label:r,permissions:i}){s(this,"t");s(this,"n");s(this,"key_label");s(this,"metadata");this.t=e,this.n=t,r&&(this.key_label=r),this.metadata=[],i&&this.metadata.push({tag:G,value:i})}set ephClaim(e){this.metadata.push({tag:x,value:e.toJSON()})}get queryPath(){return"keygen"}get requestSchema(){return{Request:[{name:"setup",type:"KeygenSetupOpts"},{name:"challenge",type:"string"}],KeygenSetupOpts:[{name:"t",type:"uint32"},{name:"n",type:"uint32"},{name:"metadata",type:"TaggedValue[]"}],TaggedValue:U}}},P=class{constructor({t:e,key_id:t,message:r}){s(this,"t");s(this,"key_id");s(this,"message");this.t=e,this.key_id=t,this.message=r}get queryPath(){return"signgen"}},f=class{constructor({n:e,key_id:t}){s(this,"n");s(this,"key_id");s(this,"metadata");this.n=e,this.key_id=t,this.metadata=[],this.metadata.push({tag:z,value:t})}set ephClaim(e){this.metadata.push({tag:x,value:e.toJSON()})}get queryPath(){return"addEphemeralKey"}get requestSchema(){return{Request:[{name:"setup",type:"AddEphemeralKeyOpts"},{name:"challenge",type:"string"}],AddEphemeralKeyOpts:[{name:"n",type:"uint32"},{name:"metadata",type:"TaggedValue[]"}],TaggedValue:U}}},I=class{constructor(e,t,r,i){s(this,"authModule");s(this,"threshold");s(this,"totalNodes");s(this,"wp_client");u(t<2,"Threshold = ".concat(t," must be at least 2")),u(r<t,"Total nodes = ".concat(r," must be greater or equal to threshold = ").concat(t)),this.threshold=t,this.totalNodes=r,this.authModule=i,this.wp_client=e}async generateKey(e){let t=new g({t:this.threshold,n:this.totalNodes,permissions:e,key_label:void 0});return this.setEphClaimOf(t),await this.wp_client.startKeygen({setup:t,authModule:this.authModule})}async signMessage(e,t){h("keyId",e),h("message",t);let r=new P({t:this.threshold,key_id:e,message:t});return await this.wp_client.startSigngen({setup:r,authModule:this.authModule})}async addEphemeralKey(e){h("keyId",e);let t=new f({n:this.totalNodes,key_id:e});return this.setEphClaimOf(t),await this.wp_client.addEphemeralKey({setup:t,authModule:this.authModule})}setEphClaimOf(e){e.ephClaim=this.authModule.ephClaim}};var Y={name:"SilentShard authentication",version:"0.1.0"},X=[{name:"name",type:"string"},{name:"version",type:"string"}];function Z(n,e,t){let r;return n instanceof g?r=new g({t:n.t,n:n.n,key_label:n.key_label,permissions:void 0}):r=new f({n:n.n,key_id:n.key_id}),r.ephClaim=t,{types:y({EIP712Domain:X},n.requestSchema),domain:Y,primaryType:"Request",message:{setup:r,challenge:e}}}async function R({setup:n,eoa:e,challenge:t,browserWallet:r,ephClaim:i}){let a=Z(n,t,i),o=await r.signTypedData(e,a);return{credentials:{credentials:i.toJSON(),method:"eoa",id:e},signature:o}}import{ed25519 as te}from"@noble/curves/ed25519";import{Base64 as T}from"js-base64";import{hexToBytes as M}from"viem";async function N({user:n,challenge:e,rpConfig:t,ephClaim:r}){let i=M("0x".concat(e),{size:32}),a={publicKey:{authenticatorSelection:{residentKey:"preferred",userVerification:"required"},challenge:i,excludeCredentials:[],pubKeyCredParams:[{type:"public-key",alg:-7},{type:"public-key",alg:-257}],rp:{name:t.rpName,id:t.rpId},user:A(y({},n),{id:T.toUint8Array(n.id)})}},o=await navigator.credentials.create(a);if(o===null)throw new Error("No credential returned");let p=c(o.response.attestationObject),d={rawCredential:JSON.stringify({authenticatorAttachment:o.authenticatorAttachment,id:o.id,rawId:c(o.rawId),response:{attestationObject:p,clientDataJSON:c(o.response.clientDataJSON)},type:o.type}),origin:t.rpName,rpId:t.rpId};return{credentials:{credentials:r.toJSON(),method:"passkey",id:o.id},signature:JSON.stringify(d)}}async function D({challenge:n,allowCredentialId:e,rpConfig:t,ephClaim:r}){let i=M("0x".concat(n),{size:32}),a=e?[{type:"public-key",id:T.toUint8Array(e)}]:[],o={publicKey:{userVerification:"required",challenge:i,allowCredentials:a}},p=await navigator.credentials.get(o);if(p===null)throw new Error("Failed to get navigator credentials");let l=p.response,d=l.userHandle;if(d===null)throw new Error("User handle cannot be null");let B=c(l.signature),W={rawCredential:JSON.stringify({authenticatorAttachment:p.authenticatorAttachment,id:p.id,rawId:c(p.rawId),response:{authenticatorData:c(l.authenticatorData),clientDataJSON:c(l.clientDataJSON),signature:B,userHandle:c(d)},type:p.type}),origin:t.rpName,rpId:t.rpId};return{credentials:{credentials:r.toJSON(),method:"passkey",id:p.id},signature:JSON.stringify(W)}}import{toHex as J}from"viem";import{ed25519 as E}from"@noble/curves/ed25519";var m=class{constructor(e,t,r=3600){s(this,"ephId");s(this,"ephPK");s(this,"expiry");this.validateInputs(e,t,r),this.ephId=e,this.ephPK=J(t),this.expiry=Math.floor(Date.now()/1e3)+r}validateInputs(e,t,r){h("ephId",e),S(t),u(Number.isInteger(r)===!1,"lifetime must be an integer");let i=r>0&&r<=365*24*60*60;u(!i,"lifetime must be greater than 0 and less than or equal to 365 days")}toJSON(){return JSON.stringify({ephId:this.ephId,ephPK:this.ephPK,expiry:this.expiry})}};async function _({setup:n,challenge:e,ephSK:t,ephClaim:r}){let i={setup:n,challenge:e},a=new TextEncoder,o=J(E.sign(a.encode(JSON.stringify(i)),t));return{credentials:{credentials:r.toJSON(),method:"ephemeral",id:r.ephId},signature:o}}function j(){return E.utils.randomPrivateKey()}function ee(n){return E.getPublicKey(n)}import{isAddress as ne}from"viem";var K=class{constructor(e,t,r,i,a){s(this,"browserWallet");s(this,"eoa");s(this,"ephClaim");this.validateInputs(t,r),this.ephClaim=new m(e,i,a),this.browserWallet=r,this.eoa=t}validateInputs(e,t){u(!ne(e),"invalid Ethereum address format"),u(!((t==null?void 0:t.signTypedData)instanceof Function),"invalid browserWallet")}async authenticate({setup:e,challenge:t}){return await R({setup:e,eoa:this.eoa,challenge:t,browserWallet:this.browserWallet,ephClaim:this.ephClaim})}},v=class{constructor(e,t){s(this,"ephSK");s(this,"ephClaim");S(t),this.ephSK=t;let r=te.getPublicKey(this.ephSK);this.ephClaim=new m(e,r)}async authenticate({setup:e,challenge:t}){return await _({setup:e,challenge:t,ephSK:this.ephSK,ephClaim:this.ephClaim})}},b=class{constructor(e,t,r,i,a,o){s(this,"rpConfig");s(this,"allowCredentialId");s(this,"user");s(this,"ephClaim");this.ephClaim=new m(i,a,o),this.rpConfig=e,this.user=t,this.allowCredentialId=r}async authenticate({setup:e,challenge:t}){let r=e.queryPath==="addEphemeralKey";if(this.allowCredentialId||r)return await D({allowCredentialId:this.allowCredentialId,challenge:t,rpConfig:this.rpConfig,ephClaim:this.ephClaim});if(this.user)return await N({user:this.user,challenge:t,rpConfig:this.rpConfig,ephClaim:this.ephClaim});throw new Error("Invalid arguments for passkey authentication")}};import{publicKeyToAddress as q,toAccount as Ve}from"viem/accounts";import{secp256k1 as re}from"@noble/curves/secp256k1";import{hashMessage as ze,hashTypedData as Ye,keccak256 as Xe,serializeSignature as Ze,serializeTransaction as je,toHex as tt}from"viem";function ie(n){if(n.startsWith("0x")&&(n=n.slice(2)),n.startsWith("04"))return q("0x".concat(n," "));if(n.startsWith("02")||n.startsWith("03")){let e=re.ProjectivePoint.fromHex(n).toHex(!1);return q("0x".concat(e))}else throw new Error("Invalid public key")}export{K as EOAAuth,v as EphAuth,I as NetworkSigner,b as PasskeyAuth,C as WalletProviderServiceClient,ie as computeAddress,j as generateEphPrivateKey,ee as getEphPublicKey};
